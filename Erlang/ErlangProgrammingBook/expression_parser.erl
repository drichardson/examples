%
% Exercise 3-8: Evaluating and Compiling Expressions
%
% Strings are fully parenthesized and can include the following binary operators: +, -, *.
% Additionally, the unary ~ (negative) operator is supported.
%
% Example input strings:
% (4+3)
% ((5-3)*2)
% ~23
% (~25+3)

-module(expression_parser).
-export([parse/1, evaluate/1, pretty_print/1, compile/1, simulate/1, simplify/1, optimize/1]).

%
% parse converts Txt to an Abstract Syntax Tree
%
parse(Txt) ->
	[Ast, []] = expression(Txt),
	Ast.

% The parse helper methods adhere to the following method signature: [ Ast, UnparsedText ] = f(Text).
% That is, f() takes input text and returns a list where the first element is an
% abstract syntax tree and the second is the unparsed text. If a method fails, the empty
% list is returned.

expression(Txt) ->
	[FirstTerm, Txt2] = term(Txt),
	case operator(Txt2) of
		[Operator, Txt3] ->
			[SecondTerm, Txt4] = term(Txt3),
			[{Operator, FirstTerm, SecondTerm}, Txt4];
		[] ->
			[FirstTerm, Txt2]
	end.
	
operator([$+ | Txt]) -> [plus, Txt];
operator([$- | Txt]) -> [minus, Txt];
operator([$* | Txt]) -> [times, Txt];
operator([$/ | Txt]) -> [divide, Txt];
operator(_) -> [].

term(Txt) ->
	case digit(Txt) of
		[Number, Txt2] ->
			[{num, list_to_integer(Number)}, Txt2];
		[] ->
			case Txt of
				[$~ | Txt2] ->
					[Expr, Txt3] = expression(Txt2),
					[{negative, Expr}, Txt3];
				[$( | Txt2] ->
					[Expr, Txt3] = expression(Txt2),
					[$) | Txt4] = Txt3,
					[Expr, Txt4];
				[] -> []
			end
	end.

digit([Digit|Txt]) when Digit >= $0, Digit =< $9 ->
	case digit(Txt) of
		[DigitRest, UnparsedText] ->
			[[Digit | DigitRest], UnparsedText];
		[] ->
			[[Digit | ""], Txt]
	end;
digit(_) -> [].


%
% evaluate: evaluates an abstract syntax tree
%
evaluate(Ast) ->
	case Ast of
		{negative, SubAst} -> -evaluate(SubAst);
		{plus, LeftAst, RightAst} -> evaluate(LeftAst) + evaluate(RightAst);
		{minus, LeftAst, RightAst} -> evaluate(LeftAst) - evaluate(RightAst);
		{times, LeftAst, RightAst} -> evaluate(LeftAst) * evaluate(RightAst);
		{divide, LeftAst, RightAst} -> evaluate(LeftAst) / evaluate(RightAst);
		{num, Number} -> Number
	end.

%
% pretty_print: turn an abstract syntax tree into a string
%
pretty_print(Ast) ->
	case Ast of
		{negative, SubAst} -> [$~ | pretty_print(SubAst)];
		{plus, LeftAst, RightAst} -> lists:concat(["(", pretty_print(LeftAst), "+", pretty_print(RightAst), ")"]);
		{minus, LeftAst, RightAst} -> lists:concat(["(", pretty_print(LeftAst), "-", pretty_print(RightAst), ")"]);
		{times, LeftAst, RightAst} -> lists:concat(["(", pretty_print(LeftAst), "*", pretty_print(RightAst), ")"]);
		{divide, LeftAst, RightAst} -> lists:concat(["(", pretty_print(LeftAst), "/", pretty_print(RightAst), ")"]);
		{num, Number} -> integer_to_list(Number)
	end.

%
% compile: transform an abstract syntax tree into a code sequence for a stack machine to evaluate
%
compile(Ast) ->
	case Ast of
		{negative, SubAst} -> lists:concat([compile(SubAst), [negate]]);
		{plus, LeftAst, RightAst} -> lists:concat([compile(RightAst), compile(LeftAst), [add]]);
		{minus, LeftAst, RightAst} -> lists:concat([compile(RightAst), compile(LeftAst), [subtract]]);
		{times, LeftAst, RightAst} -> lists:concat([compile(RightAst), compile(LeftAst), [multiply]]);
		{divide, LeftAst, RightAst} -> lists:concat([compile(RightAst), compile(LeftAst), [divide]]);
		{num, Number} -> [{push, Number}]
	end.

%
% simulate: execute the code sequence generated by compile. Supports the following codes:
% push Value - push Value on the stack
% add - pops two values, adds them, pushes result
% subtract - pops two values, subtracts them, pushes result
% multiply - pops two values, multiplies them, pushes result
% divide - pops two values, divides them, pushes result
% negate - pops one value, negates it, pushes result
%
simulate(CodeSequence) -> process_code_sequence(CodeSequence, []).

process_code_sequence([Code|CodeSequence], Stack) ->
	case Code of
		{ push, Value } -> process_code_sequence(CodeSequence, [Value | Stack]);
		negate ->
			[Value | Stack2] = Stack,
			Stack3 = [-Value | Stack2],
			process_code_sequence(CodeSequence, Stack3);
		add ->
			process_code_sequence(CodeSequence, process_binary_code(fun(L,R) -> L + R end, Stack));
		subtract ->
			process_code_sequence(CodeSequence, process_binary_code(fun(L,R) -> L - R end, Stack));
		multiply ->
			process_code_sequence(CodeSequence, process_binary_code(fun(L,R) -> L * R end, Stack));
		divide ->
			process_code_sequence(CodeSequence, process_binary_code(fun(L,R) -> L / R end, Stack))
	end;
process_code_sequence([], Stack) -> Stack.

% process a binary operation and return the modified stack
process_binary_code(Operation, Stack) ->
	[LeftValue | Stack2] = Stack,
	[RightValue | Stack3] = Stack2,
	[Operation(LeftValue, RightValue) | Stack3].

%
% simplify: simplify an abstract syntax tree so that 0*e is transformed to 0, 1*e to e, and so on.
%
simplify(Ast) -> pretty_print(optimize(Ast)).

optimize(Ast) ->
	if
		tuple_size(Ast) == 3 ->
			binary_optimizer(Ast);
		true -> Ast
	end.
	
binary_optimizer({plus, LeftTerm, RightTerm}) ->
	LeftTermResult = evaluate(LeftTerm),
	RightTermResult = evaluate(RightTerm),
	if
		LeftTermResult == 0 -> optimize(RightTerm);
		RightTermResult == 0 -> optimize(LeftTerm);
		true -> {plus, optimize(LeftTerm), optimize(RightTerm)}
	end;
binary_optimizer({times, LeftTerm, RightTerm}) ->
	LeftTermResult = evaluate(LeftTerm),
	RightTermResult = evaluate(RightTerm),
	if
		LeftTermResult == 0 -> {num, 0};
		RightTermResult == 0 -> {num, 0};
		LeftTermResult == 1 -> optimize(RightTerm);
		RightTermResult == 1 -> optimize(LeftTerm);
		true -> {times, optimize(LeftTerm), optimize(RightTerm)}
	end;	
binary_optimizer(Ast) ->
	{Operator, Left, Right} = Ast,
	{Operator, optimize(Left), optimize(Right)}.

